
include "../plang/common/compiler.pog";
include "../grax/grax.pog";
include "src/text_editor.pog";
include "src/theme.pog";
include "src/projects.pog";

// Compile:
// -O0 -g -fsanitize=address -fno-omit-frame-pointer
// ..\plang\bin\plang.exe main.pog cflags -g -lglfw3dll -l..\plang\bin\pog_compiler


/*
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
*/


/* Big Time Ideas:
    - execution statistics: know which code paths are actually taken, how common they are, what errors may have occurred
    - integrated REPL: entire type system and API of the currently loaded project is exposed to REPL
*/

/* TODO:
    - rename file
    - builtin terminal
    - display binary file
    - line color status in margin (is unsaved, is untracked addition for source controll)

    intelisense engine:
    - texteditor internal text format -> tokens for parser
    - parse_unit()
    - bind_units()
    - get list of errors to report instead of parser calling exit()
    - cleanup after a unit so that rebinding can take place (use arenas)

    priority:
        - view follow cursor horizontally, so cursor dont go off screen
        - file navigator
        - auto indentation when hit enter
        - text selection
        - backspace and delete should also work when ctrl jump is active
        - del key
        - shift-del to delete line and put into clipboard

*/

uint32 on_text_input_call_count = 0;

char* text_input_this_frame = malloc(128);

void on_text_input(GLFWwindow* w, uint32 codepoint) {
    char c = codepoint as char;
    // print("codepoint: ", codepoint, "\n");

    if file_selector_open {
        insert(*path_cursor, c);
    } else if active_editor {
        insert(*active_editor.cursor, c);
    }

    text_input_this_frame[on_text_input_call_count++] = c;
}


void on_key_input(GLFWwindow* window, int32 key, int32 scancode, int32 action, int32 mods) {

    if action == GLFW_RELEASE return;

    if file_selector_open {
        perform_cursor_operation(*path_cursor, key, mods);
    } else if active_editor {
        text_editor_recive_keyboard_input(active_editor, key, mods);
    }



    switch (mods) {
        case 0: switch (key) {
            case GLFW_KEY_F11: toggle_fullscreen(main_window); break;

            case GLFW_KEY_ESCAPE: file_selector_open = false; break;
        } break;

        case GLFW_MOD_CONTROL: switch (key) {
            case GLFW_KEY_PAGE_UP: if active_editor.prev active_editor = active_editor.prev; break;
            case GLFW_KEY_PAGE_DOWN: if active_editor.next active_editor = active_editor.next; break;

            case GLFW_KEY_P: file_selector_open = true; break;

            case GLFW_KEY_N: insert_texteditor(texteditor_new()); break;
            case GLFW_KEY_W: texteditor_free(active_editor); break;
        } break;

        case GLFW_MOD_ALT: switch (key) {
        } break;
    }
}

void on_drop(GLFWwindow* window, int32 path_count, char** paths) {

    glfwFocusWindow(window);

    for i : 0 .. path_count {
        let ed = open_text_file(paths[i]);
    }
}

void on_window_focus(GLFWwindow* window, int32 focused) {
    if focused {
        // glfwSetWindowOpacity(window, 1);
    } else {
        // glfwSetWindowOpacity(window, 0.8);
    }
}

int32 main() {

    grax_init();
    glfwSetCharCallback(main_window, on_text_input);
    glfwSetKeyCallback(main_window, on_key_input);
    glfwSetDropCallback(main_window, on_drop);
    glfwSetWindowFocusCallback(main_window, on_window_focus);


    init_themes();
    init_languages();

    // load_all_projects_in_folder("D:/Documents/repos");

    insert_texteditor(texteditor_new());
    open_text_file("src/text_editor.pog");

    file_selector_layer = create_layer();
    immediate_layer.next_layer = *file_selector_layer;

    path_cursor.line = line_new();
    path_cursor.column = 0;

    update_files();

    while grax_loop() {

        // if key(GLFW_KEY_UP) view_pos.y += 0.1;
        // if key(GLFW_KEY_DOWN) view_pos.y -= 0.1;

        if key(GLFW_KEY_LEFT_CONTROL) {
            if key('-') {
                active_editor.glyph_height *= 0.9;
                active_editor.view_pos.y = active_editor.cursor_pos.y * 0.9;
            } else if key('=') {
                active_editor.glyph_height *= 1.1;
                active_editor.view_pos.y = active_editor.cursor_pos.y * 1.1;
            }
        }


        if active_editor {
            active_editor.view_pos.y += mouse_scroll * 0.1;

            draw_texteditor(*immediate_layer, active_editor);

            active_editor.view_pos.y = lerp(0.1, active_editor.view_pos.y, active_editor.cursor_pos.y);

        } else draw_project_selection_menu();

        if file_selector_open {
            render_file_selection_menu(*file_selector_layer);
        }



        text_input_this_frame[on_text_input_call_count] = 0;
        // if on_text_input_call_count != 0 print("\"", text_input_this_frame, "\"\n");
        on_text_input_call_count = 0;
    }

    return 0;
}

RenderLayer file_selector_layer;
bool file_selector_open = false;
FileInfo* current_files; // list
Cursor path_cursor;


void update_files() {
    if current_files list_delete(current_files);

    current_files = get_all_files("src", false);
    for 0 .. list_length(current_files) {
        print(current_files[it], "\n");
    }
}

void render_file_selection_menu(RenderLayer* layer) {
    vec2 size = make_vec(1.5, 1.8);
    vec2 path_start = { -size.x / 2, size.y / 2 };
    rect(layer, vec2_zero, size, Blue);
    text(layer, path_start, 0.08, to_string(path_cursor.line.sb), White);


    const glyph_height = 0.08;
    vec2 list_pos = add(path_start, make_vec(0.1, - 0.1));
    for 0 .. list_length(current_files) {
        text(layer, list_pos, glyph_height, current_files[it].path, White);
        list_pos.y -= glyph_height * 2;
    }
}

